
⭐️は重要; 🌕は注意事項; 💫は参考論文

## Core concepts
[Data files: QIIME2 artifacts]
    Data produced by QIIME2 exist as QIIME2 artifacts. 
        A QIIME2 artifact contains data and metadata.
        The metadata describes things about the data, such as its type, format, 
        and how it was generated (provenance). 
        A QIIME2 artifact typically has the .qza file extension when stored in a file.

    Since QIIME 2 works with artifacts instead of data files (e.g. FASTA files),
        you must create a QIIME2 artifact by importing data. 
        You can import data at any step in an analysis, 
        🌕 though typically you will start by importing raw sequence data. 
        QIIME2 also has tools to export data from an artifact. See the importing guide for details.

    By using QIIME2 artifacts instead of simple data files, QIIME2 can automatically track the type, 
        format, and provenance of data for researchers. 
        Using artifacts instead of data files enables researchers to focus on the analyses they want to perform, 
        instead of the particular format the data needs to be in for an analysis.

    ⭐️ Artifacts enable QIIME2 to track, in addition to the data itself, 
        🌕 the provenance of how the data came to be. With an artifact’s provenance, 
        you can trace back to all previous analyses that were run to produce the artifact, 
        including the input data used at each step. This automatic, integrated, 
        and decentralized provenance tracking of data enables a researcher to archive artifacts, 
        or for example, send an artifact to a collaborator, with the ability to understand exactly how the artifact was created.
        This enables replicability and reproducibility of analyses, 
        as well as generation of diagrams and text that can be used in the methods section of a paper.
        Provenance also supports and encourages the proper attribution to underlying tools 
        (e.g. FastTree to build a phylogenetic tree) used to generate the artifact.

[Data files: visualizations]
    Visualizations are another type of data generated by QIIME2. 
        🌕 When written to disk, visualization files typically have the .qzv file extension.
        Visualizations contain similar types of metadata as QIIME 2 artifacts,
        including provenance information. Similar to QIIME 2 artifacts,
        🌕 visualizations are standalone information that can be archived or shared with collaborators.
    In contrast to QIIME 2 artifacts, visualizations are terminal outputs of an analysis,
        and can represent, for example, a statistical results table, an interactive visualization,
        static images, or really any combination of visual data representations.
        🌕 Since visualizations are terminal outputs, they cannot be used as input to other analyses in QIIME 2.
        ⭐️ https://view.qiime2.org/ <.qzvを共有する際に使用>


[Semantic types] → https://docs.qiime2.org/2024.2/semantic-types/ 
    Every artifact generated by QIIME 2 has a semantic type associated with it.
        Semantic types enable QIIME 2 to identify artifacts that are suitable inputs to an analysis.
        For example, if an analysis expects a distance matrix as input, 
        QIIME 2 can determine which artifacts have a distance matrix semantic type 
        and prevent incompatible artifacts from being used in the analysis 
        (e.g. an artifact representing a phylogenetic tree).
    Semantic types also help users avoid semantically incorrect analyses.
        For example, a feature table could contain presence/absence data 
        (i.e., a 1 to indicate that an OTU was observed at least one time in a given sample,
        and a 0 to indicate than an OTU was not observed at least one time in a given sample).
        However, if that feature table were provided to an analysis computing a quantitative diversity metric 
        where OTU abundances are included in the calculation (e.g., weighted UniFrac), 
        the analysis would complete successfully, but the result would not be meaningful.


[Plugins] → https://docs.qiime2.org/2024.2/plugins/available/ 
    🌕 QIIME 2 microbiome analyses are made available to users via plugins.
        To perform analyses with QIIME 2, you will install one or more plugins
        that provide the specific analyses you are interested in. 
        For example, if you want to demultiplex your raw sequence data, 
        you might use the q2-demux QIIME 2 plugin, or if you’re wanting to perform alpha- or beta-diversity analyses, you could use the q2-diversity plugin.


[Methods and visualizers]
    QIIME2 plugins define methods and visualizers that are used to perform analyses.
        🌕 A method accepts some combination of QIIME 2 artifacts and parameters as input, and produces one or more QIIME 2 artifacts as output. 
        🌕 These output artifacts could subsequently be used as input to other QIIME 2 methods or visualizers. 
        🌕 Methods can produce intermediate or terminal outputs in a QIIME 2 analysis. 
        For example, the rarefy method defined in the q2-feature-table plugin accepts a feature table artifact 
            and sampling depth as input and produces a rarefied feature table artifact as output. 
            This rarefied feature table artifact could then be used in another analysis, 
            such as alpha diversity calculations provided by the alpha method in q2-diversity.
    🌕 A visualizer is similar to a method in that it accepts some combination of QIIME 2 artifacts and parameters as input. 
        In contrast to a method, a visualizer produces exactly one visualization as output. 
        Visualizations, by definition, cannot be used as input to other QIIME 2 methods or visualizers. 
        Thus, visualizers can only produce terminal output in a QIIME 2 analysis.


## User Glossary
    <action>
    メソッド、ビジュアライザー、パイプラインの総称。アクションは常にQIIME 2プラグインによって定義される。
    <アーティファクト>
    アーティファクトは、一般的に分析の中間データを表すと考えられるQIIME 2の結果です。つまり、アーティファクトはQIIME 2によって生成され、（人間ではなく）QIIME 2によって消費されることを意図しています。成果物は、データをQIIME 2にインポートすることによって、あるいはQIIME 2のアクションから出力することによって生成される。ファイルに書き出す場合、成果物は通常.qzaという拡張子を持ち、これはQIIME Zipped Artifactの略である。アーティファクトは、QIIME 2アクションへの入力として提供したり、Python 3で使用するためのQIIME 2 Artifact APIやRで使用するためのqiime2Rなどのツールで読み込んだり、他のソフトウェアで使用するためにQIIME 2からエクスポートしたりすることができる。
    <データ実証>
    分散型データ実証を参照。
    <データフォーマット>
    ディスク上に保存されたファイルまたは複数のファイルとしてのアーティファクトのビュー。QIIME 2は多くのデータ（またはファイル）形式をサポートしており、特定のセマンティックタイプのQIIME 2成果物をインポートまたはエクスポートする際に、複数のデータ形式が利用できることがある。
    <データ型>
    インメモリーデータ表現としての成果物のビュー。データ型は一般的に、アーティファクトAPIユーザーまたはプラグイン開発者のみが遭遇する。QIIME 2は多くのデータ型をサポートしており、指定されたセマンティックタイプのQIIME 2アーティファクトを表示するために、複数のデータ型が利用できることがある。
    <分散型データ実証>
    QIIME 2の結果がどのように生成されたかを記述する情報。これには、すべてのパラメーターの値、およびUUIDとしてのすべての入力と結果への参照を含む、成果物の生成につながったQIIME 2のすべてのアクションの詳細が含まれる。データ実証にはさらに、QIIME 2の結果の生成に関連する文献引用が含まれる。これらの引用は、与えられたQIIME 2の結果に由来するすべての出版物に含まれなければならない。
    すべてのQIIME 2の結果には、QIIME 2 Viewで可視化できるデータ実績が埋め込まれている。データ実証は、（たとえば）すべての結果に関する記録を保持する中央集中型のデータベースに保存されるのとは対照的に、結果そのものに埋め込まれているため、QIIME 2のデータ実証は分散型であると説明される。
    <ディストリビューション>
    一緒にインストールされるように設計されたQIIME 2プラグインのコレクション。これらは一般的にテーマごとにグループ化されている。例えば、Amplicon Distributionはマイクロバイオームのアンプリコンデータの解析のためのプラグインのコレクションを提供し、Shotgun Distributionはマイクロバイオームのショットガンメタゲノミクスデータの解析のためのプラグインのコレクションを提供する。
    <機能>
    操作上の分類単位、配列バリアント、遺伝子、代謝物などの観測単位。QIIME 2は様々なタイプのfeatureをサポートできるため、この総称を使用している。
    <入力>
    アクションに提供される人工物（すなわち、非原始的なもの）。例えば、tableはq2-feature-tableプラグインのfilter-featuresアクションの入力である。
    <メソッド>
    QIIME 2アクションの一種で、入力として1つ以上の成果物またはパラメータを受け取り、出力として1つ以上の成果物を生成する。たとえば、q2-feature-tableプラグインのfilter-featuresアクションはメソッドである。
    <出力>
    アクションの実行によって生成される結果。たとえば、filtered-table は q2-feature-table プラグインの filter-features アクションからの出力。
    <パラメータ>
    アクションに提供されるプリミティブ (つまり、アーティファクトではないもの)。たとえば、min-frequency は q2-feature-table プラグインの filter-features アクションのパラメータ。プリミティブ型 を参照ください。
    <パイプライン>
    QIIME 2のアクションの一種で、通常は2つ以上の他のアクションを組み合わせる。パイプラインは入力として1つ以上の成果物やパラメータを受け取り、出力として1つ以上の結果( 成果物や可視化)を生成する。例えば、q2-diversityプラグインのcore-metricsアクションはパイプラインである。
    <プラグイン>
    プラグインは、アクションの形で分析機能を提供する。すべてのプラグインはすべてのインターフェースからアクセスできる。プラグインは誰でも開発・配布することができる。この原稿を書いている時点では、QIIME 2のインストールドキュメントで、いくつかのプラグインのコレクション（つまりディストリビューション）が参照されています。追加プラグインをインストールすることができ、追加プラグインの発見を可能にする主要なリソースはQIIME 2ライブラリです。QIIME 2 Forumのアカウントを持っている人なら誰でも、QIIME 2 Libraryでプラグインを共有することができます。
    <実績>
    分散型データ実証を参照。
    <プリミティブ型>
    QIIME 2アクションのパラメータを定義するために使用される型。例えば、文字列（すなわちテキスト）、整数、ブーリアン（すなわち真偽値）はプリミティブである。プリミティブはアクションへの入力としてのみ使用され、QIIME 2によって出力として生成されることはありません。
    <qza>
    アーティファクトを参照。
    <qzv>
    visualization を参照。
    <結果>
    成果物または視覚化の総称。
    <サンプル>
    分析における個々の調査単位。
    <セマンティックタイプ: semantic type>
    意味型はQIIME 2におけるデータの意味を記述する。QIIME 2におけるすべての結果は、それらに関連する単一の意味型を持ち、QIIME 2にデータをインポートする際、ユーザーはそのデータの意味型を提供しなければならない。
    QIIME 2によるセマンティック型の使用は、データについて他者とコミュニケーションするための曖昧さのない方法を提供し、QIIME 2がデータについて推論し、ユーザーがエラーを防ぐのを助けることを可能にする。セマンティック型が何であり、QIIME 2によってどのように使われるかを説明するには、例が役に立つ。QIIME 2には、Phylogeny[Rooted]とPhylogeny[Unrooted]という2つの関連するセマンティック型があり、それぞれ根付きの系統樹と根付かない系統樹を表している。根付き系統樹と非根付き系統樹はどちらもnewickファイルに格納することができ、ファイルを解析しなければ系統樹が根付きかどうかを簡単に見分けることはできない。q2-diversityプラグインのベータ系統樹法のようないくつかのアクションは、ルート化された系統樹にのみ適用されるべきである。セマンティックタイプを系統樹のアーティファクトに関連付けることで、QIIME 2は、まずファイルを解析し（これは時間がかかるかもしれないので、エラーがユーザーに提示されるまでの時間を遅らせるかもしれない）、そしておそらく観察されたことに基づいて仮定することなく、アクションに正しいタイプのデータが提供されているかどうかを判断することができる。もしユーザーが誤って、QIIME 2のアクションには受け入れられないセマンティックタイプのデータを提供した場合、QIIME 2はこの不一致を素早く検出し、エラーとその修正方法に関する詳細な情報をユーザーに提供することができる。
    意味型は、データがディスク上でどのように表現されるかを定義するデータフォーマットと混同してはならない。例えば、もう一つのQIIME 2のセマンティック型であるFeatureTable[Frequency]は、BIOM形式のファイルやタブ区切りのテキストファイルに書き込むことができる。データ形式とセマンティック型を区別することで、QIIME 2はユーザーのニーズに応じて異なるファイル形式のインポートやエクスポートをサポートすることができる。また、セマンティック型をデータ型と混同してはならない。例えば、FeatureTable[Frequency]セマンティック型は、メモリ上では、biom.Tableオブジェクトまたはpandas.DataFrameオブジェクトとして表現することができ、異なるアプリケーションでは、これらの表現のいずれかが他よりも有用であるかもしれない。どちらのメモリ内表現が使用されても、データの意味は同じです。データ型と意味型を区別することで、QIIME 2は、開発者とユーザーが、与えられたタスクに対して最も便利なデータ構造を選択できるようにしている。
    <型>
    型は曖昧な用語であるため、より具体的な意味型、プリミティブ型、データ形式、またはデータ型という用語を優先して、この用語の使用を避けるようにしている。
    <UUID>
    QIIME 2は、すべての結果とアクションのすべての実行を参照するために、UUID（Universally Unique Identifiers）を使用する。これらは、たとえば、ある成果物が、データ実証を使用して、アクションの特定の実行から出力として生成されたことを決定するために使用することができる。UUIDは、QIIME 2の成果物を無効にすることなく、決して変更することができないので、QIIME 2の結果を参照する曖昧さのない方法である（たとえば、変更しやすく、したがって結果を追跡するのに信頼できないファイル名とは異なる）。
    <view>
    アーティファクトのデータの特定の表現、たとえばデータ形式やデータ型。
    <visualizer>
    QIIME 2アクションの一種で、入力として1つ以上の成果物またはパラメータを受け取り、出力として正確に1つの視覚化を生成する。たとえば、q2-feature-tableプラグインのsummarizeアクションはビジュアライザである。
    <可視化>
    可視化は、分析における端末出力を表すQIIME 2の結果であり、QIIME 2によって生成され、（QIIME 2や他のソフトウェアによって消費されるのではなく）人間によって消費されることを意図していることを意味します。可視化はQIIME 2のビジュアライザーまたはパイプラインによってのみ生成できます。ファイルに書き込まれる場合、可視化には通常、QIIME Zipped Visualizationの略である.qzvという拡張子がつきます。可視化は、QIIME 2がインストールされていないシステムでもQIIME 2 Viewで見ることができ、QIIME 2インターフェースは通常、独自の表示サポートを提供します（QIIME 2コマンドラインインターフェースで利用可能なqiime tools viewコマンドなど）。


## Conceptual overview of QIIME 2
    🌕 All amplicon/metagenome sequencing experiments begin, at some point or another, as raw sequence data.
    This is probably FASTQ data, containing DNA sequences and quality scores for each base.

    All amplicon/metagenome sequencing experiments begin, at some point or another, as raw sequence data. 
    This is probably FASTQ data, containing DNA sequences and quality scores for each base.

    🌕 We must demultiplex these reads to determine which sample each read came from.

    🌕 Reads should then be denoised into amplicon sequence variants (ASVs) 
    or clustered into operational taxonomic units (OTUs) to achieve two goals:
        ・reducing sequence errors
        ・dereplicating sequences

    🌕 The resulting feature table and representative sequences are key pieces of data.
        Don’t lose them! A feature table is essentially a matrix of samples x observations, 
        i.e., the number of times each “feature” (OTUs, ASVs, etc) is observed in each sample in a data set.

    🌕 We can do many things with this feature table. Common analyses include: → OTSs化されたexcel.fileのこと
        ・Taxonomic classification of sequences (a.k.a., “what species are present?”)
        ・Alpha and beta diversity analyses, or measures of diversity within and between samples, respectively (a.k.a., “how similar are my samples?”)
        ・Many diversity analyses rely on the phylogenetic similarity between individual features. If you are sequencing phylogenetic markers (e.g., 16S rRNA genes), you can align these sequences to assess the phylogenetic relationship between each of your features.
        ・Differential abundance measurements determine which features (OTUs, ASVs, taxa, etc) are significantly more/less abundant in different experimental groups.


## Demultiplexing
    You (or whoever prepared and sequenced your samples) should know which barcode belongs to each sample — if you do not know, 
    talk to your lab mates or sequencing center. Include this barcode information in your sample metadata file.
    
    🌕 depending on the type of raw data you have imported. 
    Usually only one of the different demultiplexing actions available in q2-demux or q2-cutadapt will be applicable for your data, 
    and that is all you will need.

    🌕 Paired-end reads need to be joined at some point in the analysis. 
    https://docs.qiime2.org/2024.2/tutorials/atacama-soils/#atacama-demux
    https://docs.qiime2.org/2024.2/tutorials/read-joining/ 
    If you followed the Atacama soils tutorial, you will see that this happens automatically during denoising with q2-dada2. 
    However, if you want to use q2-deblur or an OTU clustering method (as described in more detail below), 
    use q2-vsearch to join these reads before proceeding, as shown in the demultiplexing workflow. 


## Denoising and clustering
    We denoise our sequences to remove and/or correct noisy reads. 🔊

    🌕 We dereplicate our sequences to reduce repetition and file size/memory requirements in downstream steps 
    (don’t worry! we keep count of each replicate). 🕵️

    🌕 We cluster sequences to collapse similar sequences (e.g., those that are ≥ 97% similar to each other) into single replicate sequences. 
    This process, also known as OTU picking, was once a common procedure, 
    used to simultaneously dereplicate but also perform a sort of quick-and-dirty denoising procedure 
    (to capture stochastic sequencing and PCR errors, which should be rare and similar to more abundant centroid sequences). 
    Use denoising methods instead if you can

    🌕 The denoising methods currently available in QIIME 2 include DADA2 and Deblur. 
    🌕 To put it simply, these methods filter out noisy sequences, correct errors in marginal sequences (in the case of DADA2), 
        remove chimeric sequences, remove singletons, join denoised paired-end reads (in the case of DADA2), and then dereplicate those sequences. 😎
    https://docs.qiime2.org/2024.2/tutorials/fmt/
    ・原著論文
    💫 DADA2- High-resolution sample inference from Illumina amplicon data
    💫 Deblur Rapidly Resolves Single-Nucleotide Community Sequence Patterns

    You can learn more about those methods by reading the original publications for each. 
    Examples of DADA2 exist in the moving pictures tutorial and Fecal Microbiome Transplant study tutorial (for single-end data) 
    and Atacama soils tutorial (for paired-end data). Examples of Deblur exist in the moving pictures tutorial (for single-end data) 
    and read joining tutorial (for paired-end data). 
    🌕 Note that deblur (and also vsearch dereplicate-sequences) should be preceded by basic quality-score-based filtering, 
    🌕 but this is unnecessary for dada2. 
    🌕 Both Deblur and DADA2 contain internal chimera checking methods and abundance filtering


## Clustering
    http://qiime.org/tutorials/otu_picking.html
    https://docs.qiime2.org/2024.2/tutorials/otu-clustering/
    🌕 q2-vsearch
         de novo, closed reference, and open reference. 
         All should be preceded by basic quality-score-based filtering and followed by chimera filtering and aggressive OTU filtering 
         (the treacherous trio, a.k.a. the Bokulich method). 🙈🙉🙊
    

## The Feature Table
    🌕 The final products of all denoising and clustering methods/workflows are 
        a FeatureTable[Frequency] (feature table) artifact and a FeatureData[Sequence] (representative sequences) artifact. 
    🌕 feature-table
    https://docs.qiime2.org/2024.2/plugins/available/feature-table/
    feature tables are crucial to any QIIME 2 analysis, as the central record of all observations per sample

    🌕 feature tables are central to analysis in QIIME 2. Almost all analysis steps 
    (i.e., following demultiplexing and denoising/clustering) involve feature tables in some way. Pay attention! 😳

    ⭐️ Want to see which sequences are associated with each feature ID? 
        Use qiime metadata tabulate with your FeatureData[Sequence] artifact as input.


## Taxonomy classification and taxonomic analyses
    🌕 We can do this by comparing our query sequences (i.e., our features, be they ASVs or OTUs) to a reference database of sequences with known taxonomic composition
    🌕 Simply finding the closest alignment is not really good enough — 
    because other sequences that are equally close matches or nearly as close may have different taxonomic annotations
    🌕 we use taxonomy classifiers to determine the closest taxonomic affiliation with some degree of confidence or consensus 
    (which may not be a species name if one cannot be predicted with certainty!), based on alignment, k-mer frequencies, etc.
    💫 Optimizing taxonomic classification of marker-gene amplicon sequences with QIIME 2’s q2-feature-classifier plugin

    🌕 q2-feature-classifier
    https://docs.qiime2.org/2024.2/data-resources/
        contains three different classification methods. 
        classify-consensus-blast and classify-consensus-vsearch are both alignment-based methods that find a consensus assignment across N top hits. 
        These methods take reference database FeatureData[Taxonomy] and FeatureData[Sequence] files directly, and do not need to be pre-trained.

    Feature classification can be slow
        It all depends on the number of sequences you have, and the number of reference sequences. 
        OTU clustered sequences will take longer to classify (because often there are more). 
        🌕 Filter low-abundance features out of your sequences file before classifying, and use smaller reference databases if possible 
        if you have concerns about runtime. In practice, in “normal size” sequencing experiments (whatever that means 😜) we see variations between a few minutes (a few hundred features) to many hours (hundreds of thousands of features) for classification to complete. 

    Feature classification can be memory intensive
    We usually see minimum 4 GB RAM, maximum 32+ GB required. It all depends on the size of the reference sequences, their length, and number of query sequences…
    
    ⭐️ All classifiers produce a FeatureData[Taxonomy] artifact containing a list of taxonomy classifications for each query sequence.

    🌕 Filter your feature table and representative sequences (FeatureData[Sequence] artifact) to remove certain taxonomic groups. 
    This is useful for removing known contaminants or non-target groups, e.g., host DNA including mitochondrial or chloroplast sequences. 
    It can also be useful for focusing on specific groups for deeper analysis. See the filtering tutorial for more details and examples. 🌿🐀
    https://docs.qiime2.org/2024.2/tutorials/filtering/


## Sequence alignment and phylogeny building 
    ⭐️ Phylogeny[Rooted]
    🌕 Many diversity analyses rely on the phylogenetic similarity between individual features. 
    If you are sequencing phylogenetic markers (e.g., 16S rRNA genes), 
    you can align these sequences to assess the phylogenetic relationship between each of your features. 
    ⭐️ This phylogeny can then be used by other downstream analyses, such as UniFrac distance analyses.
    https://library.qiime2.org/plugins/q2-fragment-insertion/16/


## Diversity analysis
    https://docs.qiime2.org/2024.2/tutorials/fmt/#fmt-diversity
    In microbiome experiments, investigators frequently wonder about things like:
        ・How many different species/OTUs/ASVs are present in my samples?
        ・How much phylogenetic diversity is present in each sample?
        ・How similar/different are individual samples and groups of samples?
        ・What factors (e.g., pH, elevation, blood pressure, body site, or host species just to name a few examples) are associated with differences in microbial composition and biodiversity?

    diversity 
    https://docs.qiime2.org/2024.2/plugins/available/diversity/
    diversity core-metrics* pipelines (core-metrics and core-metrics-phylogenetic) encompass many different core diversity commands, 
    and in the process produce the main diversity-related artifacts that can be used in downstream analyses. 
    🌕 SampleData[AlphaDiversity] artifacts, which contain alpha diversity estimates for each sample in your feature table. This is the chief artifact for alpha diversity analyses.
    🌕 DistanceMatrix artifacts, containing the pairwise distance/dissimilarity between each pair of samples in your feature table. This is the chief artifact for beta diversity analyses.
    🌕 PCoAResults artifacts, containing principal coordinates ordination results for each distance/dissimilarity metric. Principal coordinates analysis is a dimension reduction technique, facilitating visual comparisons of sample (dis)simmilarities in 2D or 3D space.

    ⭐️ These are the main diversity-related artifacts. Keep them safe! We can re-use these data in all sorts of downstream analyses, or in the various actions of q2-diversity shown in the flowchart. 
    Most of these actions are demonstrated in the moving pictures tutorial so head on over there to learn more! ☔
    https://forum.qiime2.org/t/alpha-and-beta-diversity-explanations-and-commands/2282


## Fun with feature tables
    ⭐️ Analyze longitudinal data: 
    https://docs.qiime2.org/2024.2/tutorials/longitudinal/
        q2-longitudinal is a plugin for performing statistical analyses of longitudinal experiments, i.e., 
        where samples are collected from individual patients/subjects/sites repeatedly over time. 
        This includes longitudinal studies of alpha and beta diversity, and some really awesome, interactive plots. 📈🍝

    ⭐️ Predict the future (or the past) 🔮: 
    https://docs.qiime2.org/2024.2/tutorials/sample-classifier/
        q2-sample-classifier is a plugin for machine-learning 🤖 analyses of feature data. 
        Both classification and regression models are supported. This allows you to do things like:

        ・predict sample metadata as a function of feature data 
            (e.g., can we use a fecal sample to predict cancer susceptibility? Or predict wine quality based on the microbial composition of grapes before fermentation?). 🍇
            💫 Manipulation of the Gut Microbiota Reveals Role in Colon Tumorigenesis
            💫 Associations among Wine Grape Microbiome, Metabolome, and Fermentation Behavior Suggest Microbial Contribution to Regional Wine Characteristics
        ・identify features that are predictive of different sample characteristics. 🚀
        ・quantify rates of microbial maturation (e.g., to track normal microbiome development in the infant gut and the impacts of persistent malnutrition or antibiotics, diet, and delivery mode). 👶
            💫 Persistent gut microbiota immaturity in malnourished Bangladeshi children
            💫 Antibiotics, birth mode, and diet shape microbiome maturation during early life
        ・predict outliers and mislabeled samples. 👹
            💫 Supervised classification of microbiota mitigates mislabeling errors


    ⭐️ Differential abundance:
    https://docs.qiime2.org/2024.2/tutorials/moving-pictures/#ancom
        is used to determine which features are significantly more/less abundant in different groups of samples. 
        QIIME 2 currently supports a few different approaches to differential abundance testing, 
        🌕 including ancom and ancom-bc (actions in q2-composition). 👾👾👾

    ⭐️ Evaluate and control data quality: 
        q2-quality-control is a plugin for evaluating and controlling sequence data quality. This includes actions that:
            ・test the accuracy of different bioinformatic or molecular methods, 
            or of run-to-run quality variation. These actions are typically used if users have samples with known compositions, 
            e.g., mock communities, since accuracy is calculated as the similarity between the observed and expected compositions, sequences, etc. 
            But more creative uses may be possible… 🐢
            ・filter sequences based on alignment to a reference database, or that contain specific short sections of DNA (e.g., primer sequences). 
            This is useful for removing sequences that match a specific group of organisms, non-target DNA, or other nonsense. 🙃



