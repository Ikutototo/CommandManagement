
â­ï¸ã¯é‡è¦; ğŸŒ•ã¯æ³¨æ„äº‹é …; ğŸ’«ã¯å‚è€ƒè«–æ–‡

## Core concepts
[Data files: QIIME2 artifacts]
    Data produced by QIIME2 exist as QIIME2 artifacts. 
        A QIIME2 artifact contains data and metadata.
        The metadata describes things about the data, such as its type, format, 
        and how it was generated (provenance). 
        A QIIME2 artifact typically has the .qza file extension when stored in a file.

    Since QIIME 2 works with artifacts instead of data files (e.g. FASTA files),
        you must create a QIIME2 artifact by importing data. 
        You can import data at any step in an analysis, 
        ğŸŒ• though typically you will start by importing raw sequence data. 
        QIIME2 also has tools to export data from an artifact. See the importing guide for details.

    By using QIIME2 artifacts instead of simple data files, QIIME2 can automatically track the type, 
        format, and provenance of data for researchers. 
        Using artifacts instead of data files enables researchers to focus on the analyses they want to perform, 
        instead of the particular format the data needs to be in for an analysis.

    â­ï¸ Artifacts enable QIIME2 to track, in addition to the data itself, 
        ğŸŒ• the provenance of how the data came to be. With an artifactâ€™s provenance, 
        you can trace back to all previous analyses that were run to produce the artifact, 
        including the input data used at each step. This automatic, integrated, 
        and decentralized provenance tracking of data enables a researcher to archive artifacts, 
        or for example, send an artifact to a collaborator, with the ability to understand exactly how the artifact was created.
        This enables replicability and reproducibility of analyses, 
        as well as generation of diagrams and text that can be used in the methods section of a paper.
        Provenance also supports and encourages the proper attribution to underlying tools 
        (e.g. FastTree to build a phylogenetic tree) used to generate the artifact.

[Data files: visualizations]
    Visualizations are another type of data generated by QIIME2. 
        ğŸŒ• When written to disk, visualization files typically have the .qzv file extension.
        Visualizations contain similar types of metadata as QIIME 2 artifacts,
        including provenance information. Similar to QIIME 2 artifacts,
        ğŸŒ• visualizations are standalone information that can be archived or shared with collaborators.
    In contrast to QIIME 2 artifacts, visualizations are terminal outputs of an analysis,
        and can represent, for example, a statistical results table, an interactive visualization,
        static images, or really any combination of visual data representations.
        ğŸŒ• Since visualizations are terminal outputs, they cannot be used as input to other analyses in QIIME 2.
        â­ï¸ https://view.qiime2.org/ <.qzvã‚’å…±æœ‰ã™ã‚‹éš›ã«ä½¿ç”¨>

[Semantic types] â†’ https://docs.qiime2.org/2024.2/semantic-types/ 
    Every artifact generated by QIIME 2 has a semantic type associated with it.
        Semantic types enable QIIME 2 to identify artifacts that are suitable inputs to an analysis.
        For example, if an analysis expects a distance matrix as input, 
        QIIME 2 can determine which artifacts have a distance matrix semantic type 
        and prevent incompatible artifacts from being used in the analysis 
        (e.g. an artifact representing a phylogenetic tree).
    Semantic types also help users avoid semantically incorrect analyses.
        For example, a feature table could contain presence/absence data 
        (i.e., a 1 to indicate that an OTU was observed at least one time in a given sample,
        and a 0 to indicate than an OTU was not observed at least one time in a given sample).
        However, if that feature table were provided to an analysis computing a quantitative diversity metric 
        where OTU abundances are included in the calculation (e.g., weighted UniFrac), 
        the analysis would complete successfully, but the result would not be meaningful.

[Plugins] â†’ https://docs.qiime2.org/2024.2/plugins/available/ 
    ğŸŒ• QIIME 2 microbiome analyses are made available to users via plugins.
        To perform analyses with QIIME 2, you will install one or more plugins
        that provide the specific analyses you are interested in. 
        For example, if you want to demultiplex your raw sequence data, 
        you might use the q2-demux QIIME 2 plugin, or if youâ€™re wanting to perform alpha- or beta-diversity analyses, you could use the q2-diversity plugin.

[Methods and visualizers]
    QIIME2 plugins define methods and visualizers that are used to perform analyses.
        ğŸŒ• A method accepts some combination of QIIME 2 artifacts and parameters as input, and produces one or more QIIME 2 artifacts as output. 
        ğŸŒ• These output artifacts could subsequently be used as input to other QIIME 2 methods or visualizers. 
        ğŸŒ• Methods can produce intermediate or terminal outputs in a QIIME 2 analysis. 
        For example, the rarefy method defined in the q2-feature-table plugin accepts a feature table artifact 
            and sampling depth as input and produces a rarefied feature table artifact as output. 
            This rarefied feature table artifact could then be used in another analysis, 
            such as alpha diversity calculations provided by the alpha method in q2-diversity.
    ğŸŒ• A visualizer is similar to a method in that it accepts some combination of QIIME 2 artifacts and parameters as input. 
        In contrast to a method, a visualizer produces exactly one visualization as output. 
        Visualizations, by definition, cannot be used as input to other QIIME 2 methods or visualizers. 
        Thus, visualizers can only produce terminal output in a QIIME 2 analysis.


## User Glossary
    <action>
    ãƒ¡ã‚½ãƒƒãƒ‰ã€ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ã€ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç·ç§°ã€‚ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯å¸¸ã«QIIME 2ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚Œã‚‹ã€‚
    <ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆ>
    ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã¯ã€ä¸€èˆ¬çš„ã«åˆ†æã®ä¸­é–“ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã¨è€ƒãˆã‚‰ã‚Œã‚‹QIIME 2ã®çµæœã§ã™ã€‚ã¤ã¾ã‚Šã€ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã¯QIIME 2ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã€ï¼ˆäººé–“ã§ã¯ãªãï¼‰QIIME 2ã«ã‚ˆã£ã¦æ¶ˆè²»ã•ã‚Œã‚‹ã“ã¨ã‚’æ„å›³ã—ã¦ã„ã¾ã™ã€‚æˆæœç‰©ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚’QIIME 2ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã‚ã‚‹ã„ã¯QIIME 2ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰å‡ºåŠ›ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã‚‹ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã™å ´åˆã€æˆæœç‰©ã¯é€šå¸¸.qzaã¨ã„ã†æ‹¡å¼µå­ã‚’æŒã¡ã€ã“ã‚Œã¯QIIME Zipped Artifactã®ç•¥ã§ã‚ã‚‹ã€‚ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã¯ã€QIIME 2ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¸ã®å…¥åŠ›ã¨ã—ã¦æä¾›ã—ãŸã‚Šã€Python 3ã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã®QIIME 2 Artifact APIã‚„Rã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã®qiime2Rãªã©ã®ãƒ„ãƒ¼ãƒ«ã§èª­ã¿è¾¼ã‚“ã ã‚Šã€ä»–ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã«QIIME 2ã‹ã‚‰ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
    <ãƒ‡ãƒ¼ã‚¿å®Ÿè¨¼>
    åˆ†æ•£å‹ãƒ‡ãƒ¼ã‚¿å®Ÿè¨¼ã‚’å‚ç…§ã€‚
    <ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ>
    ãƒ‡ã‚£ã‚¹ã‚¯ä¸Šã«ä¿å­˜ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯è¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ã®ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã®ãƒ“ãƒ¥ãƒ¼ã€‚QIIME 2ã¯å¤šãã®ãƒ‡ãƒ¼ã‚¿ï¼ˆã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰å½¢å¼ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãŠã‚Šã€ç‰¹å®šã®ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã‚¿ã‚¤ãƒ—ã®QIIME 2æˆæœç‰©ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¾ãŸã¯ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹éš›ã«ã€è¤‡æ•°ã®ãƒ‡ãƒ¼ã‚¿å½¢å¼ãŒåˆ©ç”¨ã§ãã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚
    <ãƒ‡ãƒ¼ã‚¿å‹>
    ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãƒ¼ãƒ‡ãƒ¼ã‚¿è¡¨ç¾ã¨ã—ã¦ã®æˆæœç‰©ã®ãƒ“ãƒ¥ãƒ¼ã€‚ãƒ‡ãƒ¼ã‚¿å‹ã¯ä¸€èˆ¬çš„ã«ã€ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆAPIãƒ¦ãƒ¼ã‚¶ãƒ¼ã¾ãŸã¯ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–‹ç™ºè€…ã®ã¿ãŒé­é‡ã™ã‚‹ã€‚QIIME 2ã¯å¤šãã®ãƒ‡ãƒ¼ã‚¿å‹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãŠã‚Šã€æŒ‡å®šã•ã‚ŒãŸã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã‚¿ã‚¤ãƒ—ã®QIIME 2ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã«ã€è¤‡æ•°ã®ãƒ‡ãƒ¼ã‚¿å‹ãŒåˆ©ç”¨ã§ãã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚
    <åˆ†æ•£å‹ãƒ‡ãƒ¼ã‚¿å®Ÿè¨¼>
    QIIME 2ã®çµæœãŒã©ã®ã‚ˆã†ã«ç”Ÿæˆã•ã‚ŒãŸã‹ã‚’è¨˜è¿°ã™ã‚‹æƒ…å ±ã€‚ã“ã‚Œã«ã¯ã€ã™ã¹ã¦ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®å€¤ã€ãŠã‚ˆã³UUIDã¨ã—ã¦ã®ã™ã¹ã¦ã®å…¥åŠ›ã¨çµæœã¸ã®å‚ç…§ã‚’å«ã‚€ã€æˆæœç‰©ã®ç”Ÿæˆã«ã¤ãªãŒã£ãŸQIIME 2ã®ã™ã¹ã¦ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®è©³ç´°ãŒå«ã¾ã‚Œã‚‹ã€‚ãƒ‡ãƒ¼ã‚¿å®Ÿè¨¼ã«ã¯ã•ã‚‰ã«ã€QIIME 2ã®çµæœã®ç”Ÿæˆã«é–¢é€£ã™ã‚‹æ–‡çŒ®å¼•ç”¨ãŒå«ã¾ã‚Œã‚‹ã€‚ã“ã‚Œã‚‰ã®å¼•ç”¨ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸQIIME 2ã®çµæœã«ç”±æ¥ã™ã‚‹ã™ã¹ã¦ã®å‡ºç‰ˆç‰©ã«å«ã¾ã‚Œãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚
    ã™ã¹ã¦ã®QIIME 2ã®çµæœã«ã¯ã€QIIME 2 Viewã§å¯è¦–åŒ–ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿å®Ÿç¸¾ãŒåŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã‚‹ã€‚ãƒ‡ãƒ¼ã‚¿å®Ÿè¨¼ã¯ã€ï¼ˆãŸã¨ãˆã°ï¼‰ã™ã¹ã¦ã®çµæœã«é–¢ã™ã‚‹è¨˜éŒ²ã‚’ä¿æŒã™ã‚‹ä¸­å¤®é›†ä¸­å‹ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã•ã‚Œã‚‹ã®ã¨ã¯å¯¾ç…§çš„ã«ã€çµæœãã®ã‚‚ã®ã«åŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã‚‹ãŸã‚ã€QIIME 2ã®ãƒ‡ãƒ¼ã‚¿å®Ÿè¨¼ã¯åˆ†æ•£å‹ã§ã‚ã‚‹ã¨èª¬æ˜ã•ã‚Œã‚‹ã€‚
    <ãƒ‡ã‚£ã‚¹ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³>
    ä¸€ç·’ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚ŒãŸQIIME 2ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã€‚ã“ã‚Œã‚‰ã¯ä¸€èˆ¬çš„ã«ãƒ†ãƒ¼ãƒã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã•ã‚Œã¦ã„ã‚‹ã€‚ä¾‹ãˆã°ã€Amplicon Distributionã¯ãƒã‚¤ã‚¯ãƒ­ãƒã‚¤ã‚ªãƒ¼ãƒ ã®ã‚¢ãƒ³ãƒ—ãƒªã‚³ãƒ³ãƒ‡ãƒ¼ã‚¿ã®è§£æã®ãŸã‚ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’æä¾›ã—ã€Shotgun Distributionã¯ãƒã‚¤ã‚¯ãƒ­ãƒã‚¤ã‚ªãƒ¼ãƒ ã®ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³ãƒ¡ã‚¿ã‚²ãƒãƒŸã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿ã®è§£æã®ãŸã‚ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’æä¾›ã™ã‚‹ã€‚
    <æ©Ÿèƒ½>
    æ“ä½œä¸Šã®åˆ†é¡å˜ä½ã€é…åˆ—ãƒãƒªã‚¢ãƒ³ãƒˆã€éºä¼å­ã€ä»£è¬ç‰©ãªã©ã®è¦³æ¸¬å˜ä½ã€‚QIIME 2ã¯æ§˜ã€…ãªã‚¿ã‚¤ãƒ—ã®featureã‚’ã‚µãƒãƒ¼ãƒˆã§ãã‚‹ãŸã‚ã€ã“ã®ç·ç§°ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã€‚
    <å…¥åŠ›>
    ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«æä¾›ã•ã‚Œã‚‹äººå·¥ç‰©ï¼ˆã™ãªã‚ã¡ã€éåŸå§‹çš„ãªã‚‚ã®ï¼‰ã€‚ä¾‹ãˆã°ã€tableã¯q2-feature-tableãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®filter-featuresã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å…¥åŠ›ã§ã‚ã‚‹ã€‚
    <ãƒ¡ã‚½ãƒƒãƒ‰>
    QIIME 2ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸€ç¨®ã§ã€å…¥åŠ›ã¨ã—ã¦1ã¤ä»¥ä¸Šã®æˆæœç‰©ã¾ãŸã¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚Šã€å‡ºåŠ›ã¨ã—ã¦1ã¤ä»¥ä¸Šã®æˆæœç‰©ã‚’ç”Ÿæˆã™ã‚‹ã€‚ãŸã¨ãˆã°ã€q2-feature-tableãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®filter-featuresã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ã‚‹ã€‚
    <å‡ºåŠ›>
    ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã‚‹çµæœã€‚ãŸã¨ãˆã°ã€filtered-table ã¯ q2-feature-table ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã® filter-features ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰ã®å‡ºåŠ›ã€‚
    <ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿>
    ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«æä¾›ã•ã‚Œã‚‹ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ– (ã¤ã¾ã‚Šã€ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã§ã¯ãªã„ã‚‚ã®)ã€‚ãŸã¨ãˆã°ã€min-frequency ã¯ q2-feature-table ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã® filter-features ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€‚ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ ã‚’å‚ç…§ãã ã•ã„ã€‚
    <ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³>
    QIIME 2ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸€ç¨®ã§ã€é€šå¸¸ã¯2ã¤ä»¥ä¸Šã®ä»–ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã€‚ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¯å…¥åŠ›ã¨ã—ã¦1ã¤ä»¥ä¸Šã®æˆæœç‰©ã‚„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚Šã€å‡ºåŠ›ã¨ã—ã¦1ã¤ä»¥ä¸Šã®çµæœ( æˆæœç‰©ã‚„å¯è¦–åŒ–)ã‚’ç”Ÿæˆã™ã‚‹ã€‚ä¾‹ãˆã°ã€q2-diversityãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®core-metricsã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ã‚ã‚‹ã€‚
    <ãƒ—ãƒ©ã‚°ã‚¤ãƒ³>
    ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯ã€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å½¢ã§åˆ†ææ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹ã€‚ã™ã¹ã¦ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã€‚ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯èª°ã§ã‚‚é–‹ç™ºãƒ»é…å¸ƒã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã“ã®åŸç¨¿ã‚’æ›¸ã„ã¦ã„ã‚‹æ™‚ç‚¹ã§ã¯ã€QIIME 2ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã€ã„ãã¤ã‹ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã¤ã¾ã‚Šãƒ‡ã‚£ã‚¹ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰ãŒå‚ç…§ã•ã‚Œã¦ã„ã¾ã™ã€‚è¿½åŠ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã“ã¨ãŒã§ãã€è¿½åŠ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ç™ºè¦‹ã‚’å¯èƒ½ã«ã™ã‚‹ä¸»è¦ãªãƒªã‚½ãƒ¼ã‚¹ã¯QIIME 2ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚QIIME 2 Forumã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’æŒã£ã¦ã„ã‚‹äººãªã‚‰èª°ã§ã‚‚ã€QIIME 2 Libraryã§ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
    <å®Ÿç¸¾>
    åˆ†æ•£å‹ãƒ‡ãƒ¼ã‚¿å®Ÿè¨¼ã‚’å‚ç…§ã€‚
    <ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹>
    QIIME 2ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹å‹ã€‚ä¾‹ãˆã°ã€æ–‡å­—åˆ—ï¼ˆã™ãªã‚ã¡ãƒ†ã‚­ã‚¹ãƒˆï¼‰ã€æ•´æ•°ã€ãƒ–ãƒ¼ãƒªã‚¢ãƒ³ï¼ˆã™ãªã‚ã¡çœŸå½å€¤ï¼‰ã¯ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ã€‚ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¯ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¸ã®å…¥åŠ›ã¨ã—ã¦ã®ã¿ä½¿ç”¨ã•ã‚Œã€QIIME 2ã«ã‚ˆã£ã¦å‡ºåŠ›ã¨ã—ã¦ç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
    <qza>
    ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã‚’å‚ç…§ã€‚
    <qzv>
    visualization ã‚’å‚ç…§ã€‚
    <çµæœ>
    æˆæœç‰©ã¾ãŸã¯è¦–è¦šåŒ–ã®ç·ç§°ã€‚
    <ã‚µãƒ³ãƒ—ãƒ«>
    åˆ†æã«ãŠã‘ã‚‹å€‹ã€…ã®èª¿æŸ»å˜ä½ã€‚
    <ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã‚¿ã‚¤ãƒ—: semantic type>
    æ„å‘³å‹ã¯QIIME 2ã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿ã®æ„å‘³ã‚’è¨˜è¿°ã™ã‚‹ã€‚QIIME 2ã«ãŠã‘ã‚‹ã™ã¹ã¦ã®çµæœã¯ã€ãã‚Œã‚‰ã«é–¢é€£ã™ã‚‹å˜ä¸€ã®æ„å‘³å‹ã‚’æŒã¡ã€QIIME 2ã«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹éš›ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ãã®ãƒ‡ãƒ¼ã‚¿ã®æ„å‘³å‹ã‚’æä¾›ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚
    QIIME 2ã«ã‚ˆã‚‹ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯å‹ã®ä½¿ç”¨ã¯ã€ãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦ä»–è€…ã¨ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹ãŸã‚ã®æ›–æ˜§ã•ã®ãªã„æ–¹æ³•ã‚’æä¾›ã—ã€QIIME 2ãŒãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦æ¨è«–ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¨ãƒ©ãƒ¼ã‚’é˜²ãã®ã‚’åŠ©ã‘ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã™ã‚‹ã€‚ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯å‹ãŒä½•ã§ã‚ã‚Šã€QIIME 2ã«ã‚ˆã£ã¦ã©ã®ã‚ˆã†ã«ä½¿ã‚ã‚Œã‚‹ã‹ã‚’èª¬æ˜ã™ã‚‹ã«ã¯ã€ä¾‹ãŒå½¹ã«ç«‹ã¤ã€‚QIIME 2ã«ã¯ã€Phylogeny[Rooted]ã¨Phylogeny[Unrooted]ã¨ã„ã†2ã¤ã®é–¢é€£ã™ã‚‹ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯å‹ãŒã‚ã‚Šã€ãã‚Œãã‚Œæ ¹ä»˜ãã®ç³»çµ±æ¨¹ã¨æ ¹ä»˜ã‹ãªã„ç³»çµ±æ¨¹ã‚’è¡¨ã—ã¦ã„ã‚‹ã€‚æ ¹ä»˜ãç³»çµ±æ¨¹ã¨éæ ¹ä»˜ãç³»çµ±æ¨¹ã¯ã©ã¡ã‚‰ã‚‚newickãƒ•ã‚¡ã‚¤ãƒ«ã«æ ¼ç´ã™ã‚‹ã“ã¨ãŒã§ãã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è§£æã—ãªã‘ã‚Œã°ç³»çµ±æ¨¹ãŒæ ¹ä»˜ãã‹ã©ã†ã‹ã‚’ç°¡å˜ã«è¦‹åˆ†ã‘ã‚‹ã“ã¨ã¯ã§ããªã„ã€‚q2-diversityãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ãƒ™ãƒ¼ã‚¿ç³»çµ±æ¨¹æ³•ã®ã‚ˆã†ãªã„ãã¤ã‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ãƒ«ãƒ¼ãƒˆåŒ–ã•ã‚ŒãŸç³»çµ±æ¨¹ã«ã®ã¿é©ç”¨ã•ã‚Œã‚‹ã¹ãã§ã‚ã‚‹ã€‚ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã‚¿ã‚¤ãƒ—ã‚’ç³»çµ±æ¨¹ã®ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã«é–¢é€£ä»˜ã‘ã‚‹ã“ã¨ã§ã€QIIME 2ã¯ã€ã¾ãšãƒ•ã‚¡ã‚¤ãƒ«ã‚’è§£æã—ï¼ˆã“ã‚Œã¯æ™‚é–“ãŒã‹ã‹ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã€ã‚¨ãƒ©ãƒ¼ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æç¤ºã•ã‚Œã‚‹ã¾ã§ã®æ™‚é–“ã‚’é…ã‚‰ã›ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ï¼‰ã€ãã—ã¦ãŠãã‚‰ãè¦³å¯Ÿã•ã‚ŒãŸã“ã¨ã«åŸºã¥ã„ã¦ä»®å®šã™ã‚‹ã“ã¨ãªãã€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«æ­£ã—ã„ã‚¿ã‚¤ãƒ—ã®ãƒ‡ãƒ¼ã‚¿ãŒæä¾›ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã‚‚ã—ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒèª¤ã£ã¦ã€QIIME 2ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«ã¯å—ã‘å…¥ã‚Œã‚‰ã‚Œãªã„ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã‚¿ã‚¤ãƒ—ã®ãƒ‡ãƒ¼ã‚¿ã‚’æä¾›ã—ãŸå ´åˆã€QIIME 2ã¯ã“ã®ä¸ä¸€è‡´ã‚’ç´ æ—©ãæ¤œå‡ºã—ã€ã‚¨ãƒ©ãƒ¼ã¨ãã®ä¿®æ­£æ–¹æ³•ã«é–¢ã™ã‚‹è©³ç´°ãªæƒ…å ±ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æä¾›ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
    æ„å‘³å‹ã¯ã€ãƒ‡ãƒ¼ã‚¿ãŒãƒ‡ã‚£ã‚¹ã‚¯ä¸Šã§ã©ã®ã‚ˆã†ã«è¡¨ç¾ã•ã‚Œã‚‹ã‹ã‚’å®šç¾©ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¨æ··åŒã—ã¦ã¯ãªã‚‰ãªã„ã€‚ä¾‹ãˆã°ã€ã‚‚ã†ä¸€ã¤ã®QIIME 2ã®ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯å‹ã§ã‚ã‚‹FeatureTable[Frequency]ã¯ã€BIOMå½¢å¼ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ã‚¿ãƒ–åŒºåˆ‡ã‚Šã®ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã‚€ã“ã¨ãŒã§ãã‚‹ã€‚ãƒ‡ãƒ¼ã‚¿å½¢å¼ã¨ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯å‹ã‚’åŒºåˆ¥ã™ã‚‹ã“ã¨ã§ã€QIIME 2ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ‹ãƒ¼ã‚ºã«å¿œã˜ã¦ç•°ãªã‚‹ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚„ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã¾ãŸã€ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯å‹ã‚’ãƒ‡ãƒ¼ã‚¿å‹ã¨æ··åŒã—ã¦ã¯ãªã‚‰ãªã„ã€‚ä¾‹ãˆã°ã€FeatureTable[Frequency]ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯å‹ã¯ã€ãƒ¡ãƒ¢ãƒªä¸Šã§ã¯ã€biom.Tableã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯pandas.DataFrameã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã€ç•°ãªã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€ã“ã‚Œã‚‰ã®è¡¨ç¾ã®ã„ãšã‚Œã‹ãŒä»–ã‚ˆã‚Šã‚‚æœ‰ç”¨ã§ã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚ã©ã¡ã‚‰ã®ãƒ¡ãƒ¢ãƒªå†…è¡¨ç¾ãŒä½¿ç”¨ã•ã‚Œã¦ã‚‚ã€ãƒ‡ãƒ¼ã‚¿ã®æ„å‘³ã¯åŒã˜ã§ã™ã€‚ãƒ‡ãƒ¼ã‚¿å‹ã¨æ„å‘³å‹ã‚’åŒºåˆ¥ã™ã‚‹ã“ã¨ã§ã€QIIME 2ã¯ã€é–‹ç™ºè€…ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€ä¸ãˆã‚‰ã‚ŒãŸã‚¿ã‚¹ã‚¯ã«å¯¾ã—ã¦æœ€ã‚‚ä¾¿åˆ©ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’é¸æŠã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã„ã‚‹ã€‚
    <å‹>
    å‹ã¯æ›–æ˜§ãªç”¨èªã§ã‚ã‚‹ãŸã‚ã€ã‚ˆã‚Šå…·ä½“çš„ãªæ„å‘³å‹ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã€ãƒ‡ãƒ¼ã‚¿å½¢å¼ã€ã¾ãŸã¯ãƒ‡ãƒ¼ã‚¿å‹ã¨ã„ã†ç”¨èªã‚’å„ªå…ˆã—ã¦ã€ã“ã®ç”¨èªã®ä½¿ç”¨ã‚’é¿ã‘ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã‚‹ã€‚
    <UUID>
    QIIME 2ã¯ã€ã™ã¹ã¦ã®çµæœã¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ã™ã¹ã¦ã®å®Ÿè¡Œã‚’å‚ç…§ã™ã‚‹ãŸã‚ã«ã€UUIDï¼ˆUniversally Unique Identifiersï¼‰ã‚’ä½¿ç”¨ã™ã‚‹ã€‚ã“ã‚Œã‚‰ã¯ã€ãŸã¨ãˆã°ã€ã‚ã‚‹æˆæœç‰©ãŒã€ãƒ‡ãƒ¼ã‚¿å®Ÿè¨¼ã‚’ä½¿ç”¨ã—ã¦ã€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ç‰¹å®šã®å®Ÿè¡Œã‹ã‚‰å‡ºåŠ›ã¨ã—ã¦ç”Ÿæˆã•ã‚ŒãŸã“ã¨ã‚’æ±ºå®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚UUIDã¯ã€QIIME 2ã®æˆæœç‰©ã‚’ç„¡åŠ¹ã«ã™ã‚‹ã“ã¨ãªãã€æ±ºã—ã¦å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ããªã„ã®ã§ã€QIIME 2ã®çµæœã‚’å‚ç…§ã™ã‚‹æ›–æ˜§ã•ã®ãªã„æ–¹æ³•ã§ã‚ã‚‹ï¼ˆãŸã¨ãˆã°ã€å¤‰æ›´ã—ã‚„ã™ãã€ã—ãŸãŒã£ã¦çµæœã‚’è¿½è·¡ã™ã‚‹ã®ã«ä¿¡é ¼ã§ããªã„ãƒ•ã‚¡ã‚¤ãƒ«åã¨ã¯ç•°ãªã‚‹ï¼‰ã€‚
    <view>
    ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã®ç‰¹å®šã®è¡¨ç¾ã€ãŸã¨ãˆã°ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚„ãƒ‡ãƒ¼ã‚¿å‹ã€‚
    <visualizer>
    QIIME 2ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸€ç¨®ã§ã€å…¥åŠ›ã¨ã—ã¦1ã¤ä»¥ä¸Šã®æˆæœç‰©ã¾ãŸã¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚Šã€å‡ºåŠ›ã¨ã—ã¦æ­£ç¢ºã«1ã¤ã®è¦–è¦šåŒ–ã‚’ç”Ÿæˆã™ã‚‹ã€‚ãŸã¨ãˆã°ã€q2-feature-tableãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®summarizeã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ã§ã‚ã‚‹ã€‚
    <å¯è¦–åŒ–>
    å¯è¦–åŒ–ã¯ã€åˆ†æã«ãŠã‘ã‚‹ç«¯æœ«å‡ºåŠ›ã‚’è¡¨ã™QIIME 2ã®çµæœã§ã‚ã‚Šã€QIIME 2ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã€ï¼ˆQIIME 2ã‚„ä»–ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã«ã‚ˆã£ã¦æ¶ˆè²»ã•ã‚Œã‚‹ã®ã§ã¯ãªãï¼‰äººé–“ã«ã‚ˆã£ã¦æ¶ˆè²»ã•ã‚Œã‚‹ã“ã¨ã‚’æ„å›³ã—ã¦ã„ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚å¯è¦–åŒ–ã¯QIIME 2ã®ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ã¾ãŸã¯ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«ã‚ˆã£ã¦ã®ã¿ç”Ÿæˆã§ãã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¾ã‚Œã‚‹å ´åˆã€å¯è¦–åŒ–ã«ã¯é€šå¸¸ã€QIIME Zipped Visualizationã®ç•¥ã§ã‚ã‚‹.qzvã¨ã„ã†æ‹¡å¼µå­ãŒã¤ãã¾ã™ã€‚å¯è¦–åŒ–ã¯ã€QIIME 2ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„ã‚·ã‚¹ãƒ†ãƒ ã§ã‚‚QIIME 2 Viewã§è¦‹ã‚‹ã“ã¨ãŒã§ãã€QIIME 2ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯é€šå¸¸ã€ç‹¬è‡ªã®è¡¨ç¤ºã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã—ã¾ã™ï¼ˆQIIME 2ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§åˆ©ç”¨å¯èƒ½ãªqiime tools viewã‚³ãƒãƒ³ãƒ‰ãªã©ï¼‰ã€‚


## Conceptual overview of QIIME 2
    ğŸŒ• All amplicon/metagenome sequencing experiments begin, at some point or another, as raw sequence data.
    This is probably FASTQ data, containing DNA sequences and quality scores for each base.

    All amplicon/metagenome sequencing experiments begin, at some point or another, as raw sequence data. 
    This is probably FASTQ data, containing DNA sequences and quality scores for each base.

    ğŸŒ• We must demultiplex these reads to determine which sample each read came from.

    ğŸŒ• Reads should then be denoised into amplicon sequence variants (ASVs) 
    or clustered into operational taxonomic units (OTUs) to achieve two goals:
        ãƒ»reducing sequence errors
        ãƒ»dereplicating sequences

    ğŸŒ• The resulting feature table and representative sequences are key pieces of data.
        Donâ€™t lose them! A feature table is essentially a matrix of samples x observations, 
        i.e., the number of times each â€œfeatureâ€ (OTUs, ASVs, etc) is observed in each sample in a data set.

    ğŸŒ• We can do many things with this feature table. Common analyses include: â†’ OTSsåŒ–ã•ã‚ŒãŸexcel.fileã®ã“ã¨
        ãƒ»Taxonomic classification of sequences (a.k.a., â€œwhat species are present?â€)
        ãƒ»Alpha and beta diversity analyses, or measures of diversity within and between samples, respectively (a.k.a., â€œhow similar are my samples?â€)
        ãƒ»Many diversity analyses rely on the phylogenetic similarity between individual features. If you are sequencing phylogenetic markers (e.g., 16S rRNA genes), you can align these sequences to assess the phylogenetic relationship between each of your features.
        ãƒ»Differential abundance measurements determine which features (OTUs, ASVs, taxa, etc) are significantly more/less abundant in different experimental groups.

    [Demultiplexing]
        You (or whoever prepared and sequenced your samples) should know which barcode belongs to each sample â€” if you do not know, 
        talk to your lab mates or sequencing center. Include this barcode information in your sample metadata file.
        
        ğŸŒ• depending on the type of raw data you have imported. 
        Usually only one of the different demultiplexing actions available in q2-demux or q2-cutadapt will be applicable for your data, 
        and that is all you will need.

        ğŸŒ• Paired-end reads need to be joined at some point in the analysis. 
        https://docs.qiime2.org/2024.2/tutorials/atacama-soils/#atacama-demux
        https://docs.qiime2.org/2024.2/tutorials/read-joining/ 
        If you followed the Atacama soils tutorial, you will see that this happens automatically during denoising with q2-dada2. 
        However, if you want to use q2-deblur or an OTU clustering method (as described in more detail below), 
        use q2-vsearch to join these reads before proceeding, as shown in the demultiplexing workflow. 

    [Denoising and clustering]
        We denoise our sequences to remove and/or correct noisy reads. ğŸ”Š

        ğŸŒ• We dereplicate our sequences to reduce repetition and file size/memory requirements in downstream steps 
        (donâ€™t worry! we keep count of each replicate). ğŸ•µï¸

        ğŸŒ• We cluster sequences to collapse similar sequences (e.g., those that are â‰¥ 97% similar to each other) into single replicate sequences. 
        This process, also known as OTU picking, was once a common procedure, 
        used to simultaneously dereplicate but also perform a sort of quick-and-dirty denoising procedure 
        (to capture stochastic sequencing and PCR errors, which should be rare and similar to more abundant centroid sequences). 
        Use denoising methods instead if you can

        ğŸŒ• The denoising methods currently available in QIIME 2 include DADA2 and Deblur. 
        ğŸŒ• To put it simply, these methods filter out noisy sequences, correct errors in marginal sequences (in the case of DADA2), 
            remove chimeric sequences, remove singletons, join denoised paired-end reads (in the case of DADA2), and then dereplicate those sequences. ğŸ˜
        https://docs.qiime2.org/2024.2/tutorials/fmt/
        ãƒ»åŸè‘—è«–æ–‡
        ğŸ’« DADA2- High-resolution sample inference from Illumina amplicon data
        ğŸ’« Deblur Rapidly Resolves Single-Nucleotide Community Sequence Patterns

        You can learn more about those methods by reading the original publications for each. 
        Examples of DADA2 exist in the moving pictures tutorial and Fecal Microbiome Transplant study tutorial (for single-end data) 
        and Atacama soils tutorial (for paired-end data). Examples of Deblur exist in the moving pictures tutorial (for single-end data) 
        and read joining tutorial (for paired-end data). 
        ğŸŒ• Note that deblur (and also vsearch dereplicate-sequences) should be preceded by basic quality-score-based filtering, 
        ğŸŒ• but this is unnecessary for dada2. 
        ğŸŒ• Both Deblur and DADA2 contain internal chimera checking methods and abundance filtering

    [Clustering]
        http://qiime.org/tutorials/otu_picking.html
        https://docs.qiime2.org/2024.2/tutorials/otu-clustering/
        ğŸŒ• q2-vsearch
            de novo, closed reference, and open reference. 
            All should be preceded by basic quality-score-based filtering and followed by chimera filtering and aggressive OTU filtering 
            (the treacherous trio, a.k.a. the Bokulich method). ğŸ™ˆğŸ™‰ğŸ™Š
        
    [The Feature Table]
        ğŸŒ• The final products of all denoising and clustering methods/workflows are 
            a FeatureTable[Frequency] (feature table) artifact and a FeatureData[Sequence] (representative sequences) artifact. 
        ğŸŒ• feature-table
        https://docs.qiime2.org/2024.2/plugins/available/feature-table/
        feature tables are crucial to any QIIME 2 analysis, as the central record of all observations per sample

        ğŸŒ• feature tables are central to analysis in QIIME 2. Almost all analysis steps 
        (i.e., following demultiplexing and denoising/clustering) involve feature tables in some way. Pay attention! ğŸ˜³

        â­ï¸ Want to see which sequences are associated with each feature ID? 
            Use qiime metadata tabulate with your FeatureData[Sequence] artifact as input.

    [Taxonomy classification and taxonomic analyses]
        ğŸŒ• We can do this by comparing our query sequences (i.e., our features, be they ASVs or OTUs) to a reference database of sequences with known taxonomic composition
        ğŸŒ• Simply finding the closest alignment is not really good enough â€” 
        because other sequences that are equally close matches or nearly as close may have different taxonomic annotations
        ğŸŒ• we use taxonomy classifiers to determine the closest taxonomic affiliation with some degree of confidence or consensus 
        (which may not be a species name if one cannot be predicted with certainty!), based on alignment, k-mer frequencies, etc.
        ğŸ’« Optimizing taxonomic classification of marker-gene amplicon sequences with QIIME 2â€™s q2-feature-classifier plugin

        ğŸŒ• q2-feature-classifier
        https://docs.qiime2.org/2024.2/data-resources/
            contains three different classification methods. 
            classify-consensus-blast and classify-consensus-vsearch are both alignment-based methods that find a consensus assignment across N top hits. 
            These methods take reference database FeatureData[Taxonomy] and FeatureData[Sequence] files directly, and do not need to be pre-trained.

        Feature classification can be slow
            It all depends on the number of sequences you have, and the number of reference sequences. 
            OTU clustered sequences will take longer to classify (because often there are more). 
            ğŸŒ• Filter low-abundance features out of your sequences file before classifying, and use smaller reference databases if possible 
            if you have concerns about runtime. In practice, in â€œnormal sizeâ€ sequencing experiments (whatever that means ğŸ˜œ) we see variations between a few minutes (a few hundred features) to many hours (hundreds of thousands of features) for classification to complete. 

        Feature classification can be memory intensive
        We usually see minimum 4 GB RAM, maximum 32+ GB required. It all depends on the size of the reference sequences, their length, and number of query sequencesâ€¦
        
        â­ï¸ All classifiers produce a FeatureData[Taxonomy] artifact containing a list of taxonomy classifications for each query sequence.

        ğŸŒ• Filter your feature table and representative sequences (FeatureData[Sequence] artifact) to remove certain taxonomic groups. 
        This is useful for removing known contaminants or non-target groups, e.g., host DNA including mitochondrial or chloroplast sequences. 
        It can also be useful for focusing on specific groups for deeper analysis. See the filtering tutorial for more details and examples. ğŸŒ¿ğŸ€
        https://docs.qiime2.org/2024.2/tutorials/filtering/

    [Sequence alignment and phylogeny building]
        â­ï¸ Phylogeny[Rooted]
        ğŸŒ• Many diversity analyses rely on the phylogenetic similarity between individual features. 
        If you are sequencing phylogenetic markers (e.g., 16S rRNA genes), 
        you can align these sequences to assess the phylogenetic relationship between each of your features. 
        â­ï¸ This phylogeny can then be used by other downstream analyses, such as UniFrac distance analyses.
        https://library.qiime2.org/plugins/q2-fragment-insertion/16/

    [Diversity analysis]
        https://docs.qiime2.org/2024.2/tutorials/fmt/#fmt-diversity
        In microbiome experiments, investigators frequently wonder about things like:
            ãƒ»How many different species/OTUs/ASVs are present in my samples?
            ãƒ»How much phylogenetic diversity is present in each sample?
            ãƒ»How similar/different are individual samples and groups of samples?
            ãƒ»What factors (e.g., pH, elevation, blood pressure, body site, or host species just to name a few examples) are associated with differences in microbial composition and biodiversity?

        diversity 
        https://docs.qiime2.org/2024.2/plugins/available/diversity/
        diversity core-metrics* pipelines (core-metrics and core-metrics-phylogenetic) encompass many different core diversity commands, 
        and in the process produce the main diversity-related artifacts that can be used in downstream analyses. 
        ğŸŒ• SampleData[AlphaDiversity] artifacts, which contain alpha diversity estimates for each sample in your feature table. This is the chief artifact for alpha diversity analyses.
        ğŸŒ• DistanceMatrix artifacts, containing the pairwise distance/dissimilarity between each pair of samples in your feature table. This is the chief artifact for beta diversity analyses.
        ğŸŒ• PCoAResults artifacts, containing principal coordinates ordination results for each distance/dissimilarity metric. Principal coordinates analysis is a dimension reduction technique, facilitating visual comparisons of sample (dis)simmilarities in 2D or 3D space.

        â­ï¸ These are the main diversity-related artifacts. Keep them safe! We can re-use these data in all sorts of downstream analyses, or in the various actions of q2-diversity shown in the flowchart. 
        Most of these actions are demonstrated in the moving pictures tutorial so head on over there to learn more! â˜”
        https://forum.qiime2.org/t/alpha-and-beta-diversity-explanations-and-commands/2282

    [Fun with feature tables]
        â­ï¸ Analyze longitudinal data: 
        https://docs.qiime2.org/2024.2/tutorials/longitudinal/
            q2-longitudinal is a plugin for performing statistical analyses of longitudinal experiments, i.e., 
            where samples are collected from individual patients/subjects/sites repeatedly over time. 
            This includes longitudinal studies of alpha and beta diversity, and some really awesome, interactive plots. ğŸ“ˆğŸ

        â­ï¸ Predict the future (or the past) ğŸ”®: 
        https://docs.qiime2.org/2024.2/tutorials/sample-classifier/
            q2-sample-classifier is a plugin for machine-learning ğŸ¤– analyses of feature data. 
            Both classification and regression models are supported. This allows you to do things like:

            ãƒ»predict sample metadata as a function of feature data 
                (e.g., can we use a fecal sample to predict cancer susceptibility? Or predict wine quality based on the microbial composition of grapes before fermentation?). ğŸ‡
                ğŸ’« Manipulation of the Gut Microbiota Reveals Role in Colon Tumorigenesis
                ğŸ’« Associations among Wine Grape Microbiome, Metabolome, and Fermentation Behavior Suggest Microbial Contribution to Regional Wine Characteristics
            ãƒ»identify features that are predictive of different sample characteristics. ğŸš€
            ãƒ»quantify rates of microbial maturation (e.g., to track normal microbiome development in the infant gut and the impacts of persistent malnutrition or antibiotics, diet, and delivery mode). ğŸ‘¶
                ğŸ’« Persistent gut microbiota immaturity in malnourished Bangladeshi children
                ğŸ’« Antibiotics, birth mode, and diet shape microbiome maturation during early life
            ãƒ»predict outliers and mislabeled samples. ğŸ‘¹
                ğŸ’« Supervised classification of microbiota mitigates mislabeling errors


        â­ï¸ Differential abundance:
        https://docs.qiime2.org/2024.2/tutorials/moving-pictures/#ancom
            is used to determine which features are significantly more/less abundant in different groups of samples. 
            QIIME 2 currently supports a few different approaches to differential abundance testing, 
            ğŸŒ• including ancom and ancom-bc (actions in q2-composition). ğŸ‘¾ğŸ‘¾ğŸ‘¾

        â­ï¸ Evaluate and control data quality: 
            q2-quality-control is a plugin for evaluating and controlling sequence data quality. This includes actions that:
                ãƒ»test the accuracy of different bioinformatic or molecular methods, 
                or of run-to-run quality variation. These actions are typically used if users have samples with known compositions, 
                e.g., mock communities, since accuracy is calculated as the similarity between the observed and expected compositions, sequences, etc. 
                But more creative uses may be possibleâ€¦ ğŸ¢
                ãƒ»filter sequences based on alignment to a reference database, or that contain specific short sections of DNA (e.g., primer sequences). 
                This is useful for removing sequences that match a specific group of organisms, non-target DNA, or other nonsense. ğŸ™ƒ


## QIIME 2 for Experienced Microbiome Researchers

[Why switch to QIIME 2?]
    ğŸŒ• QIIME 2 reduces inappropriate analyses by defining specific data types and restricting methods only to their appropriate data type inputs. 
    It also keeps track of everything thatâ€™s been done to a given data file in the provenance metadata associated with each QIIME 2 artifact

    ğŸŒ• by wrapping tools into a common framework, data processing pipelines are streamlined. With QIIME 2, most data processing workflows can be consolidated into one (or a few) bash scripts, 
    reducing the number of different programs or executables you need to call and the number of re-formatting data steps that are necessary.

[Pro-tips for power users]
    Pro-tip #1: QIIME 2 artifacts are just zip files. If at any point you want to look at what actual files are in the .qza artifact, 
    you can use qiime tools export to extract the data file directly (which is basically just a wrapper for unzip). 
    Alternatively, you can also unzip your artifact directly (unzip -k file.qza) and look through the files in the data/ folder.

    Pro-tip #2: the QIIME 2 command line interface tools are slow because they have to unzip and re-zip the data contained in the artifacts each time you call them. 
    ğŸŒ• If you need to process your data more interactively, you might want to use the Python API - it is much faster since objects can be simply stored in memory. 
    You can learn more about the different QIIME 2 interfaces.
    https://docs.qiime2.org/2024.2/interfaces/

[Data processing steps]
    Importing raw sequence (FASTQ) data into QIIME 2
    Demultiplexing data (i.e. mapping each sequence to the sample it came from)
    Removing non-biological parts of the sequences (i.e. primers)
    Performing quality control and:
        denoising sequences with DADA2 or deblur, and/or
        quality filtering, length trimming, and clustering with VSEARCH or dbOTU
    Assigning taxonomy
    Analyze data and gain insight!

[Importing data into QIIME 2] Relevant plugin: qiime tools import
    If youâ€™re using QIIME 2 to process your data, the first thing you need to do is get that data into a format that QIIME 2 can understand. 
    Various importing methods currently available in QIIME 2 are highlighted in the QIIME 2 importing tutorial.

    â­ï¸ If youâ€™re importing FASTQ data that youâ€™ve generated, youâ€™ll likely need to generate a manifest file, 
        which is just a text file that maps each FASTQ file to its sample ID and direction (if applicable)
    â­ï¸ --type 'SampleData[PairedEndSequencesWithQuality]' flags (or their respective paired-end types)
        Otherwise if you donâ€™t have one of these two very specific formats, youâ€™ll need to make the manifest file to give import instructions on what and how to import your files.

[Demultiplexing sequences] Relevant plugins: q2-demux / cutadapt
    ğŸŒ• If you have reads from multiple samples in the same file, youâ€™ll need to demultiplex your sequences.
    â­ï¸ If your barcodes have already been removed from the reads and are in a separate file, you can use q2-demux to demultiplex these
    â­ï¸ If your barcodes are still in your sequences, you can use functions from the cutadapt plugin. 
        The cutadapt demux-single method looks for barcode sequences at the beginning of your reads (5â€™ end) with a certain error tolerance, 
        removes them, and returns sequence data separated by each sample.
        https://forum.qiime2.org/t/demultiplexing-and-trimming-adapters-from-reads-with-q2-cutadapt/2313
        https://cutadapt.readthedocs.io/en/stable/index.html

[Merging reads] Relevant plugin: q2-vsearch
    ğŸŒ• Whether or not you need to merge reads depends on how you plan to cluster or denoise 
        your sequences into amplicon sequence variants (ASVs) or operational taxonomic units (OTUs)
    â­ï¸ If you plan to use deblur or OTU clustering methods next, join your sequences now
    â­ï¸ If you plan to use dada2 to denoise your sequences, do not merge â€” dada2 performs read merging automatically after denoising each sequence
    if you need to merge your reads, you can use the QIIME 2 q2-vsearch plugin with the merge-pairs method

[Removing non-biological sequences] Relevant plugins: q2-cutadapt / dada2
    If your data contains any non-biological sequences (e.g. primers, sequencing adapters, PCR spacers, etc), you should remove these
    The q2-cutadapt plugin has comprehensive methods for removing non-biological sequences from paired-end or single-end data
    â­ï¸ If youâ€™re going to use DADA2 to denoise your sequences, you can remove biological sequences at the same time as you call the denoising function
        ğŸŒ• All of DADA2â€™s denoise fuctions have some sort of --p-trim parameter you can specify to remove base pairs from the 5â€™ end of your reads. 
        (Deblur does not have this functionality yet.)

[Grouping similar sequences]
    There are two main approaches for grouping similar sequences together: denoising and clustering
    ğŸŒ• Regardless of how you group your sequences, the grouping methods will output:
        ãƒ»A list of representative sequences for each of your OTUs and/or ASVs (QIIME 2 data format FeatureData[Sequence]), and
        ãƒ»A feature table which indicates how many reads of each OTU/sequence variant were observed in each sample. (QIIME 2 data format FeatureTable[Frequency])
    DADA2 and deblur will also produce a stats summary file with useful information regarding the filtering and denoising.

[Denoising] Relevant plugins: dada2 / deblur
    DADA2 calls them â€œamplicon sequence variantsâ€ (ASVs) and deblur calls them â€œsub-OTUsâ€

    â­ï¸ Preparing data for denoising
        ğŸŒ• Denoising requires little data preparation. Both DADA2 and deblur perform quality filtering, denoising, and chimera removal, 
        so you shouldnâ€™t need to perform any quality screening prior to running them. 
        That said, the deblur developers recommend doing an initial quality-filter with default settings prior to using deblur 
        (as illustrated in the â€œMoving Picturesâ€ tutorial). Q-score based filtering is built in to DADA2, so doing this quality-filter step prior to denoising with DADA2 is unnecessary.

        ğŸŒ• Both methods have an option to truncate your reads to a constant length (which occurs prior to denoising)
        In DADA2, this is the â€“p-trunc-len parameter; 
        in deblur itâ€™s â€“p-trim-length
        The truncating parameter is optional for both DADA2 and deblur (though if youâ€™re using deblur youâ€™ll need to specify â€“p-trim-length -1 to disable truncation)
        Reads shorter than the truncation length are discarded and reads longer are truncated at that position
        ãƒ»The overview tutorial has more discussion on deciding what length you should truncate to
        
        Denoising with DADA2 
        https://docs.qiime2.org/2024.2/plugins/available/dada2/
        The DADA2 plugin has multiple methods to denoise reads:
        ãƒ»denoise paired-end    requires unmerged, paired-end reads (i.e. both forward and reverse)
        ãƒ»denoise single-end    accepts either single-end or unmerged paired-end data. If you give it unmerged paired-end data, it will only use the forward reads (and do nothing with the reverse reads)
        ãƒ»denoise-pyro          accepts ion torrent data
        ğŸŒ• Note that DADA2 may be slow on very large datasets. You can increase the number of threads to use with the --p-n-threads parameter.

        Denoising with deblur
        The deblur plugin has two methods to denoise sequences:
        ãƒ»denoise-16S denoises 16S sequences.
        ãƒ»denoise-other denoises other types of sequences
        ğŸŒ• If you use denoise-16S, deblur performs an initial positive filtering step where it discards any reads which do not have a minimum 60% identity 
            similarity to sequences from the 85% OTU GreenGenes database. If you donâ€™t want to do this step, use the denoise-other method. 
        ğŸŒ• deblur can currently only denoise single-end reads. It will accept unmerged paired-end reads as input, 
            it just wonâ€™t do anything with the reverse reads. Note that deblur can take in merged reads and treat them as single-end reads, 
            â­ï¸ so you might want to merge your reads first if youâ€™re denoising with deblur
    
[OTU Clustering]
    https://docs.qiime2.org/2024.2/plugins/available/vsearch/cluster-features-de-novo/
    https://docs.qiime2.org/2024.2/plugins/available/vsearch/cluster-features-closed-reference/
    https://docs.qiime2.org/2024.2/tutorials/otu-clustering/

    To cluster your sequences, you need to make sure that:
    ğŸŒ• ãƒ»paired-end reads are merged
    ãƒ»non-biological sequences are removed
    ğŸŒ• ãƒ»reads are all trimmed to the same length
    ğŸŒ• ãƒ»low-quality reads are discarded

    Once your data are ready, youâ€™ll also need to dereplicate your reads before clustering

    Length trimming
        If for some reason your raw reads are not already all the same length, youâ€™ll need to trim them to the same length before doing OTU clustering

    Quality filtering [Relevant plugin: quality-filter]
    https://docs.qiime2.org/2024.2/plugins/available/quality-filter/
        You can perform different types of quality filtering with the quality filter plugin
        The q-score method is for single- or paired-end sequences as well as joined reads after merging (i.e. SampleData[PairedEndSequencesWithQuality | SequencesWithQuality] | JoinedSequencesWithQuality])
         ğŸŒ• The option descriptions for each method cover the different types of available quality filtering

    Dereplicating sequences [Relevant plugin: q2-vsearch]
    https://docs.qiime2.org/2024.2/plugins/available/vsearch/
    https://docs.qiime2.org/2024.2/plugins/available/vsearch/dereplicate-sequences/
        â­ï¸ Sequences can be clustered de novo based on their genetic similarity alone (i.e. with VSEARCH) 
            or based on a combination of their genetic similarity and abundance distributions (i.e. with distribution-based clustering)
    
    de novo clustering [Relevant plugins: q2-vsearch / q2-dbotu] 
    â†’ 2ã¤ã®optionã§Cludteringå¯èƒ½(genetic similarity or combination of their genetic similarity and abundance distributions)
        â­ï¸ Sequences can be clustered de novo based on their genetic similarity alone (i.e. with VSEARCH) or 
        based on a combination of their genetic similarity and abundance distributions (i.e. with distribution-based clustering)
        ãƒ»Similarity-based clustering: 
        https://docs.qiime2.org/2024.2/plugins/available/vsearch/cluster-features-de-novo/
            The q2-vsearch plugin method cluster-features-de-novo clusters OTUs. 
            You can change the genetic similarity threshold with the --p-perc-identity parameter. The plugin wraps the VSEARCH --cluster_size function.
        ãƒ»Distribution-based clustering: 
        https://github.com/cduvallet/q2-dbotu
        ğŸ’« Distribution-Based Clustering: Using Ecology To Refine the Operational Taxonomic Unit
        ğŸ’« dbOTU3: A new implementation of distribution-based OTU calling
            incorporates the similarity between sequences and their abundance distribution to identify ecologically meaningful populations.
            You can learn more about this method in the plugin documentation, original paper, and the re-implementation update paper. 
            The call-otus function in the q2-dbotu plugin performs distribution-based clustering on input data

        â­ï¸ Both of these functions take as input the output of q2-vsearch dereplicate-sequences, 
            which are dereplicated sequences with QIIME 2 data type 'FeatureData[Sequence]', and a table of counts with QIIME 2 data type 'FeatureTable[Frequency]'

    closed reference clustering [Relevant plugin: q2-vsearch]
    https://docs.qiime2.org/2024.2/plugins/available/vsearch/cluster-features-closed-reference/
        Closed reference clustering groups sequences together which match the same reference sequence in a database with a certain similarity
        VSEARCH can do closed reference clustering with the cluster-features-closed-reference method. This method wraps the --usearch_global VSEARCH function
        ğŸŒ• decide which reference database to cluster against with the --i-reference-sequences flag
        â­ï¸ The input file to this flag should be a .qza file containing a fasta file with the sequences to use as references, with QIIME 2 data type FeatureData[Sequence]
    
    Assigning taxonomy [Relevant plugin: feature-classifier]
    https://docs.qiime2.org/2024.2/plugins/available/feature-classifier/
        The first involves aligning reads to reference databases directly:
        tweak with the maxaccepts, perc-identity, and min-consensus parameters
            ãƒ»classify-consensus-blast: BLAST+ local alignment
            https://docs.qiime2.org/2024.2/plugins/available/feature-classifier/classify-consensus-blast/
            ãƒ»classify-consensus-vsearch: VSEARCH global alignment
            https://docs.qiime2.org/2024.2/plugins/available/feature-classifier/classify-consensus-vsearch/
        The second approach uses a machine learning classifier to assign likely taxonomies to reads, and can be used through the classify-sklearn method
            https://docs.qiime2.org/2024.2/plugins/available/feature-classifier/classify-sklearn/
            This method needs a pre-trained model to classify the sequences: you can either download one of the pre-trained taxonomy classifiers from the data resources page, 
            or train one yourself (following the steps outlined in the feature classifier tutorial) 
            (You can also learn a lot more about the specific models implemented in the pluginâ€™s associated paper.)

[Analyze feature table and gain insight]
    Look at the data: 
        QIIME 2 has a nice taxa barplot visualizer to make visually exploring your data easy
        You can also visualize your data on a PCoA plot with the emperor plugin (after calculating beta diversity between samples)

    Build a phylogenetic tree: 
        QIIME 2 has a phylogeny plugin with different tree-building methods.

    Calculate alpha diversity of your samples:
    the diversity plugin has many alpha diversity metrics available through the alpha and alpha-phylogenetic methods.

    Calculate beta diversity between samples: 
    the diversity plugin also has these metrics available in the beta, beta-phylogenetic, and beta-phylogenetic-alt methods
    Note that the diversity core-metrics and diversity core-metrics-phylogenetic pipelines are a handy wrapper for alpha and beta diversity analyses. These are described in the overview tutorial.

    â­ï¸ Test for differences between samples, through differential abundance or distribution testing: 
    https://docs.qiime2.org/2024.2/plugins/available/diversity/beta-group-significance/
    https://docs.qiime2.org/2024.2/plugins/available/composition/
    PERMANOVA, ANOSIM, ANCOM, and ANCOM-BC are some of the relevant methods which are available in QIIME 2. 
    PERMANOVA and ANOSIM can be done with the beta-group-significance method in the diversity plugin, 
    and ANCOM and ANCOM-BC are available in the composition plugin.

    Build machine learning classifiers and regressors to make predictions: 
    the q2-sample-classifier plugin has several actions for building classifiers and regressors, and the associated â€œPredicting sample metadata values with q2-sample-classifierâ€ tutorial provides more details.

[Export the data] Relevant plugin: qiime tools export
    https://docs.qiime2.org/2024.2/tutorials/exporting/

    â­ï¸ You can also use the handy qiime2R package to import QIIME 2 artifacts directly into R.
    â­ï¸ https://github.com/jbisanz/qiime2R






